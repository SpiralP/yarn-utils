#!/usr/bin/env deno --allow-env --allow-sys --allow-read --allow-run=yarn,npx,yarn-update-dep --allow-write=package.json,yarn.lock

import { execFileSync } from "node:child_process";
import { readFile } from "node:fs/promises";
import { argv, exit } from "node:process";
import lockfile from "npm:@yarnpkg/lockfile@1.1.0";
import semver from "npm:semver@7.7.2";

interface LockfileEntry {
  dependencies?: Record<string, string>;
  integrity: string;
  resolved: string;
  version: string;
}

interface AuditAdvisoryEntry {
  module_name: string;
  patched_versions: string;
  title: string;
  vulnerable_versions: string;
}

interface AuditAdvisoryEntryUpdate {
  moduleName: string;
  patchedVersion: string;
  patchedVersions: string;
  title: string;
  vulnerableVersions: string;
}

const [severity, ignoreTitlesPath] = argv.slice(2);
if (!severity) {
  console.error("Usage: yarn-audit-fix <severity> [ignore-titles-path]");
  exit(1);
}

async function getAdvisoryEntries(): Promise<AuditAdvisoryEntryUpdate[]> {
  let output = "";
  try {
    const stdout = execFileSync(
      "yarn",
      ["audit", "--level", severity, "--json"],
      {
        stdio: ["ignore", "pipe", "inherit"],
      }
    );
    output = stdout.toString();
  } catch (e: any) {
    if (e.stdout) {
      output = e.stdout.toString();
    } else {
      throw e;
    }
  }

  let ignoreTitles: string[] = [];
  if (ignoreTitlesPath) {
    ignoreTitles = (await readFile(ignoreTitlesPath, "utf8"))
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line);
  }

  const entries = output
    .toString()
    .split("\n")
    .filter((line) => line)
    .map((line) => JSON.parse(line))
    .map((obj) => obj?.data?.advisory)
    .filter((obj): obj is AuditAdvisoryEntry => obj);

  const entriesByKey: Record<string, AuditAdvisoryEntryUpdate> = {};
  for (const {
    module_name: moduleName,
    patched_versions: patchedVersions,
    title,
    vulnerable_versions: vulnerableVersions,
  } of entries) {
    if (ignoreTitles.includes(title)) {
      console.log(`Ignoring: ${title}`);
      continue;
    }

    const patchedVersion = semver.minVersion(patchedVersions)?.toString();
    if (!patchedVersion) {
      console.warn(
        `Could not determine minVersion for ${moduleName} with patchedVersions ${patchedVersions}`
      );
      continue;
    }

    if (
      entriesByKey[moduleName]?.patchedVersion &&
      semver.lt(patchedVersion, entriesByKey[moduleName].patchedVersion)
    ) {
      console.log(
        `Skipping ${moduleName} with patchedVersion ${patchedVersion} because we already have ${entriesByKey[moduleName].patchedVersion}`
      );
      continue;
    }

    entriesByKey[moduleName] = {
      moduleName,
      patchedVersions,
      title,
      vulnerableVersions,
      patchedVersion,
    };
  }

  if (Object.keys(entriesByKey).length === 0) {
    console.log("No updatable vulnerabilities found");
    exit(0);
  }

  const entryUpdates = Object.values(entriesByKey);
  console.log(entryUpdates);

  return entryUpdates;
}

async function exec(file: string, ...args: string[]) {
  console.log(`$ ${[file, ...args].join(" ")}`);
  execFileSync(file, args, {
    stdio: ["ignore", "inherit", "inherit"],
  });
}

async function readYarnLock(): Promise<Record<string, LockfileEntry>> {
  const { type, object: lockfileData } = lockfile.parse(
    await readFile("yarn.lock", "utf8")
  ) as { type: "success" | unknown; object: Record<string, LockfileEntry> };

  if (type !== "success") {
    throw new Error("Failed to parse yarn.lock");
  }

  return lockfileData;
}

async function main() {
  const advisoryEntries = await getAdvisoryEntries();
  for (const {
    moduleName,
    patchedVersion,
    title,
    vulnerableVersions,
  } of advisoryEntries) {
    console.log("Updating:", {
      title,
      moduleName,
      vulnerableVersions,
      patchedVersion,
    });

    await exec("yarn-update-dep", moduleName, patchedVersion);
  }

  const lockfileData = await readYarnLock();
  for (const {
    moduleName,
    patchedVersions,
    title,
    vulnerableVersions,
  } of advisoryEntries) {
    for (const [key, value] of Object.entries(lockfileData)) {
      if (
        key.startsWith(`${moduleName}@`) &&
        semver.satisfies(value.version, vulnerableVersions)
      ) {
        console.warn("Couldn't update:", {
          title,
          moduleName,
          currentVersion: value.version,
          patchedVersions,
        });
      }
    }
  }
}

// @ts-ignore
await main();
